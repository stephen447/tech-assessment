schema {
  query: Query
}

type Query {
  EVM(network: EVM_Network!): EVMData
}

# Enum for network selection
enum EVM_Network {
  eth
  bsc
  polygon
  # other networks...
}

# Define DateTime scalar for date handling
scalar DateTime

type EVMData {
  DEXTradeByTokens(
    where: DEXTradeByTokensWhereInput
    orderBy: OrderByInput
    limit: LimitInput
  ): [DEXTradeByTokensResult]
}

input DEXTradeByTokensWhereInput {
  Block: BlockWhereInput
  Trade: TradeWhereInput
}

input BlockWhereInput {
  Time: TimeWhereInput
}

input TimeWhereInput {
  since: DateTime
}

input TradeWhereInput {
  AmountInUSD: AmountInUSDWhereInput
  Currency: CurrencyWhereInput
}

input CurrencyWhereInput {
  Name: NameWhereInput
}

input NameWhereInput {
  includesCaseInsensitive: String
}

input AmountInUSDWhereInput {
  gt: String
}

input OrderByInput {
  descendingByField: String
}

input LimitInput {
  count: Int
}

# Define field name enums for aggregation functions
enum TradeFieldEnum {
  Trade_AmountInUSD
  Trade_Buyer
  Trade_Side_AmountInUSD
  # Add other field names as needed
}

# Define field name enum for maximum parameter
enum BlockTimeEnum {
  Block_Time
}

type DEXTradeByTokensResult {
  Trade: TradeResult
  volume_usd: Float
  unique_traders: Int
  trade_count: Int
  # Define sum and uniq to accept enum values
  sum(of: TradeFieldEnum!): Float
  uniq(of: TradeFieldEnum!): Int
  count: Int
}

type TradeResult {
  Currency: CurrencyResult
  # Define PriceInUSD to accept enum for maximum
  PriceInUSD(maximum: BlockTimeEnum!): Float
}

type CurrencyResult {
  Symbol: String
  Name: String
  SmartContract: String
}
